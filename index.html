<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TZU Worship - Multipista</title>
    
    <!-- Incluyendo Tailwind CSS para un diseño moderno y responsivo -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Importando una fuente moderna y gruesa desde Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Anton&display=swap" rel="stylesheet">
    
    <style>
        /* Estilo para aplicar la fuente personalizada */
        .font-anton {
            font-family: 'Anton', sans-serif;
        }
        /* Asegura que la imagen de fondo cubra el área sin distorsionarse */
        .hero-image {
            background-image: url('IMG_311980.JPG');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
    </style>
</head>
<body class="bg-black text-white">

    <!-- Contenedor principal de la página -->
    <div class="min-h-screen flex flex-col">

        <!-- Sección de la imagen principal (Hero) -->
        <!-- La imagen se establece como fondo de este div para un mejor control -->
        <header class="hero-image h-96 md:h-screen/2 lg:h-screen/1.5 w-full relative flex items-center justify-center">
            <!-- Superposición oscura para mejorar la legibilidad del texto -->
            <div class="absolute inset-0 bg-black opacity-50"></div>
        </header>

        <!-- Sección del título -->
        <main class="flex-grow flex items-center justify-center -mt-32 md:-mt-48 z-10">
            <div class="text-center p-6">
                <!-- Título principal con la fuente y estilos solicitados -->
<img src="tzu_worship_logo 1-01.png" alt="Logo TZU Worship" class="mx-auto mb-6" style="width: 850px;">
                <p class="text-2xl sm:text-3xl md:text-4xl text-gray-300 mt-2 tracking-wide">
                    Multipista
                </p>
            </div>
        </main>
        
        <!-- Pie de página opcional -->
        <footer class="text-center p-4 text-gray-500 text-sm">
            <p>&copy; 2025 TZU Worship. Todos los derechos reservados.</p>
        </footer>

    </div>

</body>
</html>
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TZU Worship - Multipista con Forma de Onda</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --font-family-sans-serif: 'Montserrat', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            
            /* Modo Claro */
            --bg-color: #f8f9fa;
            --surface-color: #ffffff;
            --primary-color: #FF7A00; 
            --primary-color-hover: #E56E00;
            --secondary-color: #6c757d;
            --text-color: #212529; 
            --text-color-light: #f8f9fa;
            --border-color: #dee2e6;
            --accent-color: #FF7A00; 
            --warn-color: #D9534F; 
            --info-color: #FFA500;  
            --disabled-color: #e9ecef;
            --button-text-color: var(--text-color-light);
            --waveform-cursor-color: #D9534F; /* Rojo para el cursor, igual que warn-color */
        }

        :root[data-theme="dark"] {
            --bg-color: #121212;
            --surface-color: #1e1e1e;
            --primary-color: #FF8C00;
            --primary-color-hover: #FF9D2A;
            --secondary-color: #4a4a4a;
            --text-color: #e0e0e0; 
            --text-color-light: #121212;
            --border-color: #333333;
            --accent-color: #FF8C00;
            --warn-color: #E74C3C;
            --info-color: #FFAE42;
            --disabled-color: #2c2c2c;
            --button-text-color: var(--text-color-light);
            --waveform-cursor-color: #E74C3C;
        }

        body {
            font-family: var(--font-family-sans-serif);
            margin: 0;
            padding: 15px;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            font-size: 15px;
            font-weight: 400;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .app-container {
            max-width: 1200px;
            margin: 20px auto;
            background-color: var(--surface-color);
            padding: 25px 30px;
            border-radius: 16px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.07);
            transition: background-color 0.3s ease;
            position: relative; 
        }

        #loadingOverlay {
            position: fixed; 
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7); 
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; 
            color: white;
            font-size: 3em; 
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            visibility: hidden; 
            opacity: 0;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        #loadingOverlay.visible {
            visibility: visible;
            opacity: 1;
        }


        h1, h2, h3 { 
            margin-top: 0; 
            color: var(--text-color); 
            transition: color 0.3s ease;
            font-weight: 700;
        }
        h1 { 
            text-align: center; 
            margin-bottom: 30px; 
            font-size: 2.2em; 
            letter-spacing: -0.5px;
        }
        h2 { 
            margin-bottom: 20px; 
            font-size: 1.6em; 
            border-bottom: 2px solid var(--border-color); 
            padding-bottom: 10px; 
            transition: border-color 0.3s ease;
            font-weight: 600;
        }
        h3 { 
            margin-bottom: 15px; 
            font-size: 1.3em;
            font-weight: 600;
        }

        button {
            padding: 10px 18px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: 600;
            transition: background-color 0.2s ease, opacity 0.2s ease, color 0.2s ease, transform 0.1s ease;
            background-color: var(--primary-color);
            color: var(--button-text-color);
        }
        button:hover { 
            background-color: var(--primary-color-hover);
            transform: translateY(-1px);
        }
        button:active {
            transform: translateY(0px);
        }

        button:disabled {
            background-color: var(--disabled-color);
            color: var(--secondary-color);
            cursor: not-allowed;
            opacity: 0.7;
            transform: translateY(0px);
        }
        button.secondary {
            background-color: var(--secondary-color);
            color: var(--text-color-light);
        }
         button.secondary:hover {
            background-color: color-mix(in srgb, var(--secondary-color) 90%, black);
        }

        button.toggled {
            background-color: var(--info-color);
            color: var(--text-color-light);
        }
         button.toggled:hover {
            background-color: color-mix(in srgb, var(--info-color) 90%, black);
        }
        
        #themeToggleButton {
            background-color: var(--secondary-color);
            color: var(--text-color-light);
            padding: 8px 15px;
            font-size: 0.9em;
        }


        input[type="range"] { accent-color: var(--primary-color); cursor: pointer; }
        select, input[type="text"], input[type="number"] { 
            padding: 10px; border: 1px solid var(--border-color);
            border-radius: 6px; font-size: 0.95em; box-sizing: border-box;
            background-color: var(--surface-color);
            color: var(--text-color);
            transition: border-color 0.3s ease, background-color 0.3s ease, color 0.3s ease;
        }
        input[type="text"]#timeSignatureInput.invalid {
            border-color: var(--warn-color) !important; 
            box-shadow: 0 0 0 0.2rem color-mix(in srgb, var(--warn-color) 25%, transparent);
        }


        .section {
            margin-bottom: 30px; padding-bottom: 25px;
            border-bottom: 1px solid var(--border-color);
            transition: border-color 0.3s ease;
        }
        .section:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0;}

        .header-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
       
        .global-playback-controls { 
            display: flex; 
            flex-direction: column; 
            gap: 10px; 
            margin-bottom: 25px; 
        }
        #globalPlayPauseButton { 
            background-color: var(--accent-color); 
            color: var(--button-text-color); 
            font-weight: 700; 
            padding: 12px 28px; 
            font-size: 1.1em; 
            min-width: 160px; text-align: center; 
            align-self: flex-start;
            margin-bottom: 10px;
        }
        #globalPlayPauseButton.playing { background-color: var(--warn-color); }
        #globalPlayPauseButton:hover {
             background-color: color-mix(in srgb, var(--accent-color) 90%, black);
        }
        #globalPlayPauseButton.playing:hover {
             background-color: color-mix(in srgb, var(--warn-color) 90%, black);
        }

        .waveform-scrubber-container {
            width: 100%;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: stretch;
        }

        #waveformCanvas {
            width: 100%;
            height: 80px; 
            background-color: var(--surface-color); 
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        #progressCursor {
            position: absolute;
            top: 1px; /* Ajustar para estar dentro del borde del canvas */
            left: 0; 
            width: 2px; 
            height: calc(100% - 2px); /* Ajustar para estar dentro del borde del canvas */
            background-color: var(--waveform-cursor-color); 
            pointer-events: none; 
            z-index: 1; 
        }


        #globalTimeDisplay { 
            font-size: 0.9em; 
            color: var(--secondary-color); 
            min-width: 100px; 
            text-align: right; 
            font-weight: 600;
            margin-top: 5px; 
            align-self: flex-end; 
        }
        
        /* Layout para pantallas más grandes */
        @media (min-width: 769px) {
            .global-playback-controls {
                flex-direction: row;
                align-items: center;
                gap: 15px;
            }
            #globalPlayPauseButton {
                margin-bottom: 0;
                align-self: unset;
            }
            .waveform-scrubber-container {
                flex-grow: 1;
                flex-direction: row;
                align-items: center;
                gap: 12px;
            }
            #waveformCanvas {
                flex-grow: 1;
            }
            #progressCursor { /* Asegurar que la altura sea la del canvas */
                height: 80px; /* Coincidir con la altura del canvas */
                top: 50%; /* Centrar verticalmente el cursor */
                transform: translateY(-50%);
            }
            #globalTimeDisplay {
                margin-top: 0;
                align-self: center;
            }
        }


        .master-volume-control { display: flex; align-items: center; gap: 10px; margin-top:20px; }
        .master-volume-control label { font-size: 0.95em; font-weight: 600; }
        #masterVolumeSlider { flex-grow: 1; max-width: 280px;}

        .file-management { display: flex; gap: 12px; flex-wrap: wrap; margin-bottom: 20px; align-items: center; }
        #fileInputGlobal { display: none; } 
        #loadingMessage, #exportMessage { font-size: 0.9em; color: var(--secondary-color); margin-left: 10px; }
        
        .export-controls { display: flex; gap: 12px; align-items: center; margin-top: 15px;}
        .export-controls select {flex-basis: 130px;}
        #exportProgressContainer {
            width: 100%;
            background-color: var(--disabled-color);
            border-radius: 6px;
            margin-top: 10px;
            height: 12px; 
            overflow: hidden; 
            display: none; 
        }
        #exportProgressBar {
            width: 0%;
            height: 100%;
            background-color: var(--accent-color);
            transition: width 0.2s ease-out;
            border-radius: 6px;
        }


        .metronome-section { background-color: var(--bg-color); padding: 20px; border-radius: 10px; transition: background-color 0.3s ease; }
        .metronome-controls-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 18px; align-items: center; }
        .metronome-control-group { display: flex; flex-direction: column; gap: 6px; }
        .metronome-control-group label { font-size: 0.9em; color: var(--secondary-color); font-weight: 600; }
        .metronome-control-group select, .metronome-control-group input[type="text"], .metronome-control-group input[type="number"], .metronome-control-group input[type="range"] { width: 100%; }
        #metronomeToggleButton { background-color: var(--secondary-color); color: var(--text-color-light); }
        #metronomeToggleButton.active { background-color: var(--accent-color); }
        #metronomeToggleButton.active:hover { background-color: color-mix(in srgb, var(--accent-color) 90%, black); }


        .track-mix-controls {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }


        .tracks-container-wrapper { margin-top: 25px; }
        #tracksContainerPlaceholder {
            font-style: italic; color: var(--secondary-color); padding: 20px;
            text-align: center; border: 2px dashed var(--border-color); border-radius: 10px;
            transition: color 0.3s ease, border-color 0.3s ease;
            font-size: 1.05em;
        }
        
        .tracks-container { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); 
            gap: 18px; 
        }

        .track {
            background-color: var(--surface-color); padding: 15px 20px; border-radius: 10px;
            border: 1px solid var(--border-color); display: grid;
            grid-template-columns: 1fr;
            grid-template-rows: auto auto;
            grid-template-areas: "track-name" "track-controls-progress";
            gap: 12px; align-items: center;
            transition: background-color 0.2s ease, box-shadow 0.2s ease, border-color 0.3s ease;
        }
        .track:hover {
            box-shadow: 0 4px 15px rgba(0,0,0,0.06);
        }
        .track.soloed { 
            box-shadow: 0 0 0 3px var(--info-color) inset; 
            background-color: color-mix(in srgb, var(--info-color) 10%, var(--surface-color)); 
        }
        .track.muted-by-solo { opacity: 0.5; }

        .track-name {
            grid-area: track-name; font-weight: 600; color: var(--text-color);
            font-size: 1.1em; overflow: hidden; text-overflow: ellipsis;
            margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center;
            transition: color 0.3s ease;
        }
        .track-name .track-file-label {
            overflow: hidden; text-overflow: ellipsis; 
             min-width: 0; 
        }
        .track-name .track-status-indicator {
            font-size: 0.85em; font-style: italic; color: var(--secondary-color);
            margin-left: 10px; white-space: nowrap; flex-shrink: 0;
            transition: color 0.3s ease;
        }

        .track-controls-progress { grid-area: track-controls-progress; display: flex; flex-direction: column; gap: 10px; }
        .track-interactive-elements { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; } 
        .track-interactive-elements .mute-button, .track-interactive-elements .solo-button {
            color: var(--button-text-color); padding: 7px 10px; font-size: 0.85em; min-width: 45px; text-align:center; font-weight: 700; 
        }
        .track-interactive-elements .mute-button { background-color: var(--accent-color); }
        .track-interactive-elements .mute-button.muted { background-color: var(--warn-color); }
        .track-interactive-elements .mute-button:hover { background-color: color-mix(in srgb, var(--accent-color) 90%, black); }
        .track-interactive-elements .mute-button.muted:hover { background-color: color-mix(in srgb, var(--warn-color) 90%, black); }

        .track-interactive-elements .solo-button { background-color: var(--secondary-color); }
        .track-interactive-elements .solo-button.soloed { background-color: var(--info-color); color: var(--text-color-light); }
        .track-interactive-elements .solo-button:hover { background-color: color-mix(in srgb, var(--secondary-color) 90%, black); }
        .track-interactive-elements .solo-button.soloed:hover { background-color: color-mix(in srgb, var(--info-color) 90%, black); }

        .track-interactive-elements .volume-slider {
            flex-grow: 1; min-width:100px; max-width: 160px; height: 10px; 
            -webkit-appearance: none; appearance: none; background: var(--disabled-color); border-radius: 5px;
            transition: background-color 0.3s ease;
        }
        .track-interactive-elements .volume-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; background: var(--primary-color); border-radius: 50%; }
        .track-interactive-elements .volume-slider::-moz-range-thumb { width: 16px; height: 16px; background: var(--primary-color); border-radius: 50%; border: none; }

        .track-progress-bar { width: 100%; height: 8px; background-color: var(--disabled-color); border-radius: 4px; overflow: hidden; transition: background-color 0.3s ease; }
        .track-progress-bar-fill { width: 0%; height: 100%; background-color: var(--primary-color); transition: width 0.1s linear, background-color 0.3s ease; border-radius: 4px;}

        @media (max-width: 1024px) {
            .app-container {
                max-width: 95%; 
            }
             .tracks-container {
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); 
            }
        }


        @media (max-width: 768px) {
            body { padding: 10px; font-size: 14px; }
            .app-container { 
                padding: 20px 15px;
                max-width: 100%; 
            }
            h1 { font-size: 1.8em; }
            .header-controls { flex-direction: column-reverse; align-items: flex-start; gap: 10px;}
            #themeToggleButton { align-self: flex-end;}
             /* Ya estaba en .global-playback-controls general */
            /* .global-playback-controls { flex-direction: column; align-items: stretch; } */
            /* #globalPlayPauseButton { width: 100%; margin-bottom: 10px;} */
            /* .waveform-scrubber-container { width: 100%; } */ /* Ya es 100% por defecto */
            #globalTimeDisplay { text-align: center; /* margin-top: 5px; <- Ajustado por el flex-direction column del contenedor */ }
            .master-volume-control label { display:none; }
            .master-volume-control { margin-top:10px; }
            #masterVolumeSlider { max-width: none;}
            .track-interactive-elements .volume-slider { max-width: none; }
            .export-controls { flex-direction: column; align-items: stretch;}
            .export-controls button, .export-controls select { width: 100%; margin-bottom: 5px; }
            
            .tracks-container {
                grid-template-columns: 1fr;
            }
        }
        @media (max-width: 480px) {
            h1 { font-size: 1.6em; }
            h2 { font-size: 1.4em; }
            h3 { font-size: 1.2em; }
            .metronome-controls-grid { grid-template-columns: 1fr; }
            .file-management { flex-direction: column; gap: 8px; align-items: stretch;}
            .file-management:first-of-type { flex-direction: row; flex-wrap: wrap; }
            .file-management:first-of-type button { flex-grow: 1; }


            .track-name { flex-direction: column; align-items: flex-start;}
            .track-name .track-status-indicator { margin-left: 0; margin-top: 3px;}
            .track-mix-controls { flex-direction: column; align-items: stretch;}
            .track-mix-controls button { width: 100%; }
             #loadingOverlay { font-size: 2.5em; }
        }
    </style>
</head>
<body>
    <div id="loadingOverlay">
        <span id="loadingPercentage">0%</span>
    </div>
    <div class="app-container">
        <div class="header-controls">
            <h1>TZU Worship - Multipista</h1>
            <button id="themeToggleButton">🌙 Modo Oscuro</button>
        </div>

        <div class="section global-controls-section">
            <h2>Controles Globales</h2>
            <div class="global-playback-controls">
                <button id="globalPlayPauseButton" class="paused">▶️ Play</button>
                <div class="waveform-scrubber-container">
                    <canvas id="waveformCanvas"></canvas>
                    <div id="progressCursor"></div>
                    <span id="globalTimeDisplay">00:00 / 00:00</span>
                </div>
            </div>
            <div class="master-volume-control">
                <label for="masterVolumeSlider">Volumen General:</label>
                <input type="range" id="masterVolumeSlider" min="0" max="1" step="0.01" value="0.8">
            </div>
        </div>

        <div class="section file-management-section">
            <h2>Gestión de Archivos y Exportación</h2>
            <div class="file-management"> 
                <input type="file" id="fileInputGlobal" multiple accept=".mp3,.wav">
                <button id="loadFilesButton">📁 Cargar Stems Locales</button>
                <span id="loadingMessage"></span>
            </div>
            <div class="export-controls">
                <button id="exportMixButton" disabled>📤 Exportar Mezcla</button>
                <select id="exportFormatSelect">
                    <option value="wav" selected>WAV</option>
                    <option value="mp3" disabled>MP3 (Próximamente)</option>
                </select>
                <span id="exportMessage"></span>
            </div>
            <div id="exportProgressContainer">
                <div id="exportProgressBar"></div>
            </div>
        </div>

        <div class="section metronome-section-wrapper">
             <div class="metronome-section">
                <h3>Metrónomo</h3>
                <div class="metronome-controls-grid">
                    <button id="metronomeToggleButton" class="inactive">🔇 Click OFF</button>
                    <div class="metronome-control-group">
                        <label for="tempoInput">Tempo (BPM: 20-300)</label>
                        <input type="number" id="tempoInput" value="120" min="20" max="300">
                    </div>
                    <div class="metronome-control-group">
                        <label for="timeSignatureInput">Compás (ej: 4/4)</label>
                        <input type="text" id="timeSignatureInput" value="4/4" placeholder="ej: 4/4, 3/4, 7/8">
                    </div>
                    <div class="metronome-control-group">
                        <label for="clickSoundSelect">Sonido del Click</label>
                        <select id="clickSoundSelect">
                            <option value="madera_simulada" selected>Madera (Simulada)</option>
                            <option value="suave">Suave (Sine)</option>
                            <option value="seco">Seco (Square)</option>
                        </select>
                    </div>
                    <div class="metronome-control-group">
                        <label for="metronomeVolumeSlider">Volumen del Click</label>
                        <input type="range" id="metronomeVolumeSlider" min="0" max="1" step="0.01" value="0.7">
                    </div>
                </div>
            </div>
        </div>

        <div class="tracks-container-wrapper section">
            <h2>Pistas</h2>
            <div class="track-mix-controls">
                <button id="toggleGlobalSoloButton" class="secondary">🚫 Limpiar Solos</button>
                <button id="toggleGlobalMuteButton" class="secondary">🔊 Limpiar Mutes</button>
            </div>
            <div id="tracksContainerPlaceholder">Carga archivos de audio para comenzar...</div>
            <div class="tracks-container" id="tracksContainer">
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const tracksContainer = document.getElementById('tracksContainer');
            const tracksContainerPlaceholder = document.getElementById('tracksContainerPlaceholder');
            const globalPlayPauseButton = document.getElementById('globalPlayPauseButton');
            // globalScrubber eliminado
            const globalTimeDisplay = document.getElementById('globalTimeDisplay');
            const masterVolumeSlider = document.getElementById('masterVolumeSlider');
            const loadFilesButton = document.getElementById('loadFilesButton');
            const fileInputGlobal = document.getElementById('fileInputGlobal');
            const loadingMessage = document.getElementById('loadingMessage');
            const metronomeToggleButton = document.getElementById('metronomeToggleButton');
            const timeSignatureInput = document.getElementById('timeSignatureInput'); 
            const tempoInput = document.getElementById('tempoInput');
            const clickSoundSelect = document.getElementById('clickSoundSelect');
            const metronomeVolumeSlider = document.getElementById('metronomeVolumeSlider');
            const themeToggleButton = document.getElementById('themeToggleButton');

            const toggleGlobalSoloButton = document.getElementById('toggleGlobalSoloButton');
            const toggleGlobalMuteButton = document.getElementById('toggleGlobalMuteButton');

            const exportMixButton = document.getElementById('exportMixButton');
            const exportFormatSelect = document.getElementById('exportFormatSelect');
            const exportMessage = document.getElementById('exportMessage');
            const exportProgressContainer = document.getElementById('exportProgressContainer');
            const exportProgressBar = document.getElementById('exportProgressBar');

            const loadingOverlay = document.getElementById('loadingOverlay');
            const loadingPercentage = document.getElementById('loadingPercentage');

            // Nuevos elementos para la forma de onda
            const waveformCanvas = document.getElementById('waveformCanvas');
            const waveformCtx = waveformCanvas.getContext('2d');
            const progressCursor = document.getElementById('progressCursor');

            let previousSoloedTrackIds = [];
            let isSoloButtonInRestoreMode = false;
            const SOLO_BUTTON_TEXT = { CLEAR: "🚫 Limpiar Solos", RESTORE: "🔄 Restaurar Solos" };

            let previousMutedTrackIds = [];
            let isMuteButtonInRestoreMode = false;
            const MUTE_BUTTON_TEXT = { CLEAR: "🔊 Limpiar Mutes", RESTORE: "🔄 Restaurar Mutes" };


            let audioContext;
            let tracks = [];
            let masterGainNode;
            let isPlaying = false;
            let globalStartTime = 0, globalPauseOffset = 0, maxDuration = 0, animationFrameId = null;
            let nextTrackId = 0;

            // Para la forma de onda
            let mixedAudioBuffer = null; 
            let isScrubbingWaveform = false;

            let metronome = {
                isActive: false, isPlayingInternal: false, bpm: 120, 
                timeSignature: [4, 4], 
                beatsPerBar: 4, 
                beatValue: 4,   
                soundType: 'madera_simulada', 
                volume: 0.7, schedulerTimerId: null, nextNoteTime: 0.0,
                currentSchedulerBeat: 0, 
                lookahead: 25.0, scheduleAheadTime: 0.1, gainNode: null,
                clickSounds: { 
                    madera_simulada: { freq1: 2800, freq2: 2200, freq3: 2500, type: 'triangle', decay: 0.025, noiseDuration: 0.02, noiseGain: 0.15 },
                    suave: { freq1: 880, freq2: 660, freq3: 770, type: 'sine', decay: 0.05 },
                    seco: { freq1: 1500, freq2: 1000, freq3: 1200, type: 'square', decay: 0.03 }
                }
            };

            function applyTheme(theme) {
                if (theme === 'dark') {
                    document.documentElement.setAttribute('data-theme', 'dark');
                    themeToggleButton.textContent = '☀️ Modo Claro';
                } else {
                    document.documentElement.removeAttribute('data-theme');
                    themeToggleButton.textContent = '🌙 Modo Oscuro';
                }
            }

            function toggleTheme() {
                const currentTheme = document.documentElement.getAttribute('data-theme');
                if (currentTheme === 'dark') {
                    applyTheme('light');
                    localStorage.setItem('themePreference', 'light');
                } else {
                    applyTheme('dark');
                    localStorage.setItem('themePreference', 'dark');
                }
                drawWaveform(); // Redibujar forma de onda con nuevos colores
            }

            function loadThemePreference() {
                const preferredTheme = localStorage.getItem('themePreference');
                if (preferredTheme) {
                    applyTheme(preferredTheme);
                } else {
                    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches && !preferredTheme) {
                        applyTheme('dark');
                    } else {
                        applyTheme('light');
                    }
                }
            }
            themeToggleButton.addEventListener('click', toggleTheme);
            loadThemePreference();


            function initAudioContext() {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    masterGainNode = audioContext.createGain();
                    masterGainNode.gain.value = parseFloat(masterVolumeSlider.value);
                    masterGainNode.connect(audioContext.destination);

                    metronome.gainNode = audioContext.createGain();
                    metronome.gainNode.gain.value = metronome.volume;
                    metronome.gainNode.connect(audioContext.destination);

                    tracks.forEach(track => {
                        if (!track.gainNode) {
                            track.gainNode = audioContext.createGain();
                            track.gainNode.connect(masterGainNode);
                            applyEffectiveVolume(track.id);
                        }
                    });
                }
                if (audioContext.state === 'suspended') audioContext.resume();
            }
            document.body.addEventListener('click', initAudioContext, { once: true });
            document.body.addEventListener('touchstart', initAudioContext, { once: true });

            function createAndAddTrackElement({fileName, audioBuffer, fileUrl = null, sourceType = 'local', existingTrackData = {}}) {
                const trackId = `track-${nextTrackId++}`;
                const trackElement = document.createElement('div');
                trackElement.classList.add('track');
                trackElement.id = trackId;

                let displayName = fileName;
                let statusIndicatorHTML = "";
                if (sourceType === 'url' && !audioBuffer) {
                    statusIndicatorHTML = `<span class="track-status-indicator">(Cargando URL...)</span>`;
                } else if (!audioBuffer && sourceType === 'project-placeholder') {
                     statusIndicatorHTML = `<span class="track-status-indicator">(Esperando recarga...)</span>`;
                } else if (audioBuffer && sourceType === 'url'){
                     statusIndicatorHTML = `<span class="track-status-indicator">(URL Cargada)</span>`;
                }


                trackElement.innerHTML = `
                    <div class="track-name" title="${displayName}">
                        <span class="track-file-label">${displayName}</span>
                        ${statusIndicatorHTML}
                    </div>
                    <div class="track-controls-progress">
                        <div class="track-interactive-elements">
                            <button class="mute-button" title="Mute (M)">M</button>
                            <button class="solo-button" title="Solo (S)">S</button>
                            <input type="range" class="volume-slider" min="0" max="1" step="0.01" value="${existingTrackData.volume || 0.8}" title="Volumen de pista">
                        </div>
                        <div class="track-progress-bar">
                            <div class="track-progress-bar-fill"></div>
                        </div>
                    </div>
                `;
                tracksContainer.appendChild(trackElement);
                tracksContainerPlaceholder.style.display = 'none';
                exportMixButton.disabled = false;

                const newTrack = {
                    id: trackId, name: fileName, element: trackElement, audioBuffer: audioBuffer,
                    sourceNode: null, gainNode: audioContext ? audioContext.createGain() : null,
                    muteButton: trackElement.querySelector('.mute-button'),
                    soloButton: trackElement.querySelector('.solo-button'),
                    volumeSlider: trackElement.querySelector('.volume-slider'),
                    progressBarFill: trackElement.querySelector('.track-progress-bar-fill'),
                    isMuted: existingTrackData.isMuted || false, isSoloed: existingTrackData.isSoloed || false,
                    volume: existingTrackData.volume || 0.8, duration: audioBuffer ? audioBuffer.duration : 0,
                    loadedFileName: sourceType === 'local' ? fileName : (existingTrackData.loadedFileName || null),
                    fileUrl: fileUrl || existingTrackData.fileUrl,
                    sourceType: sourceType,
                    statusIndicatorElement: trackElement.querySelector('.track-status-indicator')
                };

                if (newTrack.gainNode) {
                    newTrack.gainNode.connect(masterGainNode);
                }

                newTrack.muteButton.addEventListener('click', () => toggleMute(newTrack.id));
                newTrack.soloButton.addEventListener('click', () => toggleSolo(newTrack.id));
                newTrack.volumeSlider.addEventListener('input', (event) => setTrackVolume(newTrack.id, parseFloat(event.target.value)));

                tracks.push(newTrack);
                if (audioBuffer) updateMaxDurationAndScrubber(); // Esto llamará a regenerateAndDrawWaveform
                updateAllTrackVisualsAndVolumes();
                return newTrack;
            }

            function updateTrackStatusIndicator(trackId, message, isError = false) {
                const track = findTrackById(trackId);
                if (!track) return;
                let nameContainer = track.element.querySelector('.track-name');
                let statusSpan = track.statusIndicatorElement;
                if (!statusSpan && message) {
                    const newSpan = document.createElement('span');
                    newSpan.classList.add('track-status-indicator');
                    nameContainer.appendChild(newSpan);
                    track.statusIndicatorElement = newSpan;
                    statusSpan = newSpan;
                }
                if (statusSpan) {
                    statusSpan.textContent = message ? `(${message})` : "";
                    statusSpan.style.color = isError ? 'var(--warn-color)' : 'var(--secondary-color)';
                }
            }

            function findTrackById(trackId) { return tracks.find(t => t.id === trackId); }

            function toggleMute(trackId) {
                if (!audioContext) initAudioContext();
                const track = findTrackById(trackId);
                if (!track) return;
                track.isMuted = !track.isMuted;
                updateAllTrackVisualsAndVolumes();
                // Considerar si regenerar la forma de onda global con M/S. Por ahora, no.
                // regenerateAndDrawWaveform(); 
                saveSession();
            }

            function toggleSolo(trackId) {
                if (!audioContext) initAudioContext();
                const track = findTrackById(trackId);
                if (!track) return;
                track.isSoloed = !track.isSoloed;
                updateAllTrackVisualsAndVolumes();
                // Considerar si regenerar la forma de onda global con M/S. Por ahora, no.
                // regenerateAndDrawWaveform();
                saveSession();
            }

            toggleGlobalSoloButton.addEventListener('click', () => {
                if (!audioContext) initAudioContext();
                if (!isSoloButtonInRestoreMode) {
                    const currentSoloed = tracks.filter(t => t.isSoloed).map(t => t.id);
                    if (currentSoloed.length > 0) {
                        previousSoloedTrackIds = [...currentSoloed];
                        tracks.forEach(track => { track.isSoloed = false; });
                        toggleGlobalSoloButton.textContent = SOLO_BUTTON_TEXT.RESTORE;
                        toggleGlobalSoloButton.classList.remove('secondary');
                        toggleGlobalSoloButton.classList.add('toggled');
                        isSoloButtonInRestoreMode = true;
                    } else {
                        previousSoloedTrackIds = [];
                        toggleGlobalSoloButton.textContent = SOLO_BUTTON_TEXT.CLEAR;
                        toggleGlobalSoloButton.classList.add('secondary');
                        toggleGlobalSoloButton.classList.remove('toggled');
                        isSoloButtonInRestoreMode = false;
                    }
                } else {
                    if (previousSoloedTrackIds.length > 0) {
                        tracks.forEach(track => {
                            track.isSoloed = previousSoloedTrackIds.includes(track.id);
                        });
                    } else {
                        tracks.forEach(track => { track.isSoloed = false; });
                    }
                    toggleGlobalSoloButton.textContent = SOLO_BUTTON_TEXT.CLEAR;
                    toggleGlobalSoloButton.classList.add('secondary');
                    toggleGlobalSoloButton.classList.remove('toggled');
                    isSoloButtonInRestoreMode = false;
                }
                updateAllTrackVisualsAndVolumes();
                // regenerateAndDrawWaveform(); // Si M/S afectan la onda visual
                saveSession();
            });

            toggleGlobalMuteButton.addEventListener('click', () => {
                if (!audioContext) initAudioContext();
                if (!isMuteButtonInRestoreMode) {
                    const currentMuted = tracks.filter(t => t.isMuted).map(t => t.id);
                    if (currentMuted.length > 0) {
                        previousMutedTrackIds = [...currentMuted];
                        tracks.forEach(track => { track.isMuted = false; });
                        toggleGlobalMuteButton.textContent = MUTE_BUTTON_TEXT.RESTORE;
                        toggleGlobalMuteButton.classList.remove('secondary');
                        toggleGlobalMuteButton.classList.add('toggled');
                        isMuteButtonInRestoreMode = true;
                    } else {
                        previousMutedTrackIds = [];
                        toggleGlobalMuteButton.textContent = MUTE_BUTTON_TEXT.CLEAR;
                        toggleGlobalMuteButton.classList.add('secondary');
                        toggleGlobalMuteButton.classList.remove('toggled');
                        isMuteButtonInRestoreMode = false;
                    }
                } else {
                     if (previousMutedTrackIds.length > 0) {
                        tracks.forEach(track => {
                            track.isMuted = previousMutedTrackIds.includes(track.id);
                        });
                    } else {
                        tracks.forEach(track => { track.isMuted = false; });
                    }
                    toggleGlobalMuteButton.textContent = MUTE_BUTTON_TEXT.CLEAR;
                    toggleGlobalMuteButton.classList.add('secondary');
                    toggleGlobalMuteButton.classList.remove('toggled');
                    isMuteButtonInRestoreMode = false;
                }
                updateAllTrackVisualsAndVolumes();
                // regenerateAndDrawWaveform(); // Si M/S afectan la onda visual
                saveSession();
            });


            function setTrackVolume(trackId, volumeValue) {
                if (!audioContext) initAudioContext(); const track = findTrackById(trackId);
                if (!track) return; track.volume = volumeValue;
                applyEffectiveVolume(track.id); 
                // Si el volumen afecta la forma de onda visual global
                // if (mixedAudioBuffer) regenerateAndDrawWaveform(); 
                saveSession();
            }

            function updateAllTrackVisualsAndVolumes() {
                const anySoloActive = tracks.some(t => t.isSoloed);
                tracks.forEach(track => {
                    applyEffectiveVolume(track.id, anySoloActive);
                    track.muteButton.classList.toggle('muted', track.isMuted);
                    track.soloButton.classList.toggle('soloed', track.isSoloed);
                    track.element.classList.toggle('muted-by-solo', anySoloActive && !track.isSoloed && !track.isMuted);
                    track.element.classList.toggle('soloed', track.isSoloed);
                });
            }

            function applyEffectiveVolume(trackId, anySoloActiveGlobal = tracks.some(t => t.isSoloed), gainNodeToUse = null) {
                const track = findTrackById(trackId);
                if (!track) return;

                const targetGainNode = gainNodeToUse || track.gainNode;
                if (!targetGainNode) return;

                let newGainValue = 0;
                if (track.isMuted) {
                    newGainValue = 0;
                } else if (anySoloActiveGlobal) {
                    newGainValue = track.isSoloed ? track.volume : 0;
                } else {
                    newGainValue = track.volume;
                }

                if (targetGainNode.context instanceof OfflineAudioContext) {
                    targetGainNode.gain.value = newGainValue;
                } else if (audioContext) {
                    targetGainNode.gain.setValueAtTime(newGainValue, audioContext.currentTime);
                }
            }

            function isMobileDevice() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            }

            loadFilesButton.addEventListener('click', () => fileInputGlobal.click());
            fileInputGlobal.addEventListener('change', handleMultipleFileLoad);

            async function handleMultipleFileLoad(event) {
                if (!audioContext) initAudioContext(); 
                
                const files = event.target.files; 
                if (!files.length) return;

                const MAX_TRACKS_MOBILE = 5; 
                if (isMobileDevice() && (tracks.length + files.length) > MAX_TRACKS_MOBILE) {
                    const userConfirmed = confirm(
                        `Advertencia: Estás en un dispositivo móvil e intentas cargar ${files.length} pistas adicionales (total actual + nuevas: ${tracks.length + files.length}). ` +
                        `Esto podría superar la memoria disponible y causar que la página se reinicie. ` +
                        `Se recomienda un máximo de ${MAX_TRACKS_MOBILE} pistas en total en móviles. ¿Deseas continuar bajo tu propio riesgo?`
                    );
                    if (!userConfirmed) {
                        fileInputGlobal.value = null; 
                        return; 
                    }
                }

                loadingMessage.textContent = "";
                loadingOverlay.classList.add('visible');
                loadingPercentage.textContent = '0%';
                
                let filesProcessed = 0;
                const totalFiles = files.length;
                let errorInLoading = false; 

                for (const file of files) {
                    try {
                        const arrayBuffer = await file.arrayBuffer();
                        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                        createAndAddTrackElement({fileName: file.name, audioBuffer: audioBuffer, sourceType: 'local'});
                        filesProcessed++;
                    } catch (err) { 
                        console.error(`Error decodificando ${file.name}:`, err); 
                        errorInLoading = true;
                    }
                    const percentage = Math.round((filesProcessed / totalFiles) * 100);
                    loadingPercentage.textContent = `${percentage}%`;
                    await new Promise(resolve => requestAnimationFrame(resolve)); 
                }
                
                loadingOverlay.classList.remove('visible');
                if (errorInLoading) {
                    loadingMessage.textContent = `Algunos archivos no se pudieron cargar. ${filesProcessed} de ${totalFiles} cargados.`;
                } else {
                    loadingMessage.textContent = `${filesProcessed} pista(s) local(es) cargada(s).`;
                }
                setTimeout(() => { loadingMessage.textContent = ""; }, 5000);

                if (tracks.length === 0) {
                    tracksContainerPlaceholder.style.display = 'block';
                    exportMixButton.disabled = true;
                } else {
                    tracksContainerPlaceholder.style.display = 'none';
                    exportMixButton.disabled = false;
                }
                // updateMaxDurationAndScrubber llamará a regenerateAndDrawWaveform
                updateMaxDurationAndScrubber(); 
                saveSession(); 
                fileInputGlobal.value = null;
            }

            masterVolumeSlider.addEventListener('input', (event) => {
                if (!audioContext) initAudioContext(); const newVolume = parseFloat(event.target.value);
                if (masterGainNode) masterGainNode.gain.setValueAtTime(newVolume, audioContext.currentTime);
                saveSession();
            });
            globalPlayPauseButton.addEventListener('click', () => { initAudioContext(); isPlaying ? pauseAll() : playAll(); });
            function playAll() {
                if (isPlaying || !tracks.some(t => t.audioBuffer)) return;
                const currentTime = audioContext.currentTime;
                if (globalPauseOffset >= maxDuration && maxDuration > 0) globalPauseOffset = 0; 
                
                tracks.forEach(track => {
                    if (track.audioBuffer && track.gainNode) {
                        track.sourceNode = audioContext.createBufferSource(); track.sourceNode.buffer = track.audioBuffer;
                        track.sourceNode.connect(track.gainNode); let trackOffset = globalPauseOffset;
                        if (trackOffset >= track.duration && track.duration > 0) return; 
                        track.sourceNode.start(currentTime, trackOffset);
                    }
                });
                globalStartTime = currentTime - globalPauseOffset; isPlaying = true;
                globalPlayPauseButton.textContent = '❚❚ Pause'; globalPlayPauseButton.classList.add('playing');
                if (metronome.isActive) startMetronomePlayback();
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = requestAnimationFrame(updateUI);
            }
            function pauseAll() {
                if (!isPlaying) return;
                tracks.forEach(track => {
                    if (track.sourceNode) { try { track.sourceNode.stop(); } catch (e) {}
                        track.sourceNode.disconnect(); track.sourceNode = null; }
                });
                if (audioContext) globalPauseOffset = audioContext.currentTime - globalStartTime;
                isPlaying = false; globalPlayPauseButton.textContent = '▶️ Play'; globalPlayPauseButton.classList.remove('playing');
                if (metronome.isActive) stopMetronomePlayback();
                if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
                updateUI();
            }
            // globalScrubber listeners eliminados, reemplazados por los del canvas
            
            function handleScrub(event) { // Esta función ahora se llama handleWaveformScrub
                // ... (lógica movida a handleWaveformScrub) ...
            }

            function updateUI() {
                if (!audioContext) { 
                    if (animationFrameId) cancelAnimationFrame(animationFrameId); 
                    animationFrameId = null; 
                    progressCursor.style.left = '0%';
                    return; 
                }
                let currentElapsedTime = isPlaying ? audioContext.currentTime - globalStartTime : globalPauseOffset;
                currentElapsedTime = Math.max(0, Math.min(currentElapsedTime, maxDuration)); 

                if (maxDuration > 0) {
                    globalTimeDisplay.textContent = `${formatTime(currentElapsedTime)} / ${formatTime(maxDuration)}`;
                } else {
                    globalTimeDisplay.textContent = `00:00 / 00:00`;
                }

                if (maxDuration > 0 && waveformCanvas.width > 0) {
                    const progressPercent = (currentElapsedTime / maxDuration) * 100;
                    progressCursor.style.left = `${Math.min(100, Math.max(0, progressPercent))}%`;
                } else {
                    progressCursor.style.left = '0%';
                }

                tracks.forEach(track => {
                    if (track.audioBuffer && track.duration > 0) {
                        const progress = Math.min(currentElapsedTime / track.duration, 1);
                        track.progressBarFill.style.width = `${Math.min(100, Math.max(0, progress * 100))}%`;
                    } else { 
                        track.progressBarFill.style.width = `0%`; 
                    }
                });

                if (isPlaying && maxDuration > 0 && currentElapsedTime >= maxDuration) {
                    pauseAll(); 
                    globalPauseOffset = maxDuration; 
                    progressCursor.style.left = '100%';
                }
                if (isPlaying) animationFrameId = requestAnimationFrame(updateUI);
            }
            
            async function updateMaxDurationAndScrubber() { // Renombrado y modificado
                maxDuration = tracks.reduce((max, track) => (track.audioBuffer && track.duration) ? Math.max(max, track.duration) : max, 0);
                if (maxDuration > 0) {
                    await regenerateAndDrawWaveform(); // Esperar a que la forma de onda se genere
                } else {
                    mixedAudioBuffer = null;
                    drawWaveform(); // Limpiar canvas
                }
                globalPauseOffset = Math.min(globalPauseOffset, maxDuration);
                updateUI();
            }

            function formatTime(seconds) { const min = Math.floor(seconds / 60); const sec = Math.floor(seconds % 60); return `${min < 10 ? '0' : ''}${min}:${sec < 10 ? '0' : ''}${sec}`; }

            metronomeToggleButton.addEventListener('click', () => {
                initAudioContext(); metronome.isActive = !metronome.isActive;
                if (metronome.isActive) { 
                    metronomeToggleButton.textContent = '🔊 Click ON'; 
                    metronomeToggleButton.classList.add('active'); 
                    metronomeToggleButton.classList.remove('inactive'); 
                    if (isPlaying) startMetronomePlayback(); 
                } else { 
                    metronomeToggleButton.textContent = '🔇 Click OFF'; 
                    metronomeToggleButton.classList.remove('active'); 
                    metronomeToggleButton.classList.add('inactive'); 
                    stopMetronomePlayback(); 
                }
                saveSession();
            });

            tempoInput.addEventListener('change', () => { 
                let newTempo = parseInt(tempoInput.value); 
                if (isNaN(newTempo) || newTempo < 20) {
                    newTempo = 20;
                    tempoInput.value = newTempo; 
                }
                if (newTempo > 300) {
                    newTempo = 300;
                    tempoInput.value = newTempo; 
                }
                metronome.bpm = newTempo; 
                if (metronome.isActive && isPlaying) { 
                    stopMetronomePlayback(); 
                    startMetronomePlayback(); 
                }
                saveSession();
            });
            
            timeSignatureInput.addEventListener('change', () => {
                const parts = timeSignatureInput.value.trim().split('/');
                timeSignatureInput.classList.remove('invalid'); 
                if (parts.length === 2) {
                    const num = parseInt(parts[0]);
                    const den = parseInt(parts[1]);
                    if (!isNaN(num) && !isNaN(den) && num > 0 && num <= 16 && den > 0 && [2, 4, 8, 16].includes(den)) {
                        metronome.timeSignature = [num, den];
                        metronome.beatsPerBar = num; 
                        metronome.beatValue = den;   
                        if (metronome.isActive && isPlaying) {
                            stopMetronomePlayback();
                            startMetronomePlayback();
                        }
                        saveSession();
                    } else {
                        timeSignatureInput.classList.add('invalid');
                        console.warn("Compás inválido. Se restaurará al anterior o 4/4.");
                        timeSignatureInput.value = metronome.timeSignature.join('/'); 
                    }
                } else {
                    timeSignatureInput.classList.add('invalid');
                     console.warn("Compás inválido. Se restaurará al anterior o 4/4.");
                    timeSignatureInput.value = metronome.timeSignature.join('/');
                }
            });

            clickSoundSelect.addEventListener('change', () => { 
                metronome.soundType = clickSoundSelect.value; 
                saveSession(); 
            });
            metronomeVolumeSlider.addEventListener('input', () => {
                metronome.volume = parseFloat(metronomeVolumeSlider.value);
                if (metronome.gainNode && audioContext) metronome.gainNode.gain.setValueAtTime(metronome.volume, audioContext.currentTime); 
                saveSession();
            });

            function getSecondsPerClick() {
                let secondsPerQuarterNote = 60.0 / metronome.bpm; 
                return secondsPerQuarterNote * (4 / metronome.beatValue);
            }

            function metronomeScheduler() {
                if (!audioContext || !metronome.isActive || !isPlaying) {
                    stopMetronomePlayback();
                    return;
                }
                const secondsPerClick = getSecondsPerClick();

                while (metronome.nextNoteTime < audioContext.currentTime + metronome.scheduleAheadTime) {
                    let accentType = 'normal'; 
                    if (metronome.currentSchedulerBeat === 0) {
                        accentType = 'primary';
                    } else {
                        if (metronome.beatValue === 8) { 
                            if (metronome.beatsPerBar === 6 && metronome.currentSchedulerBeat === 3) accentType = 'secondary';
                            else if (metronome.beatsPerBar === 9 && (metronome.currentSchedulerBeat === 3 || metronome.currentSchedulerBeat === 6)) accentType = 'secondary';
                            else if (metronome.beatsPerBar === 12 && (metronome.currentSchedulerBeat === 3 || metronome.currentSchedulerBeat === 6 || metronome.currentSchedulerBeat === 9)) accentType = 'secondary';
                        }
                        else if (metronome.beatsPerBar === 4 && metronome.beatValue === 4 && metronome.currentSchedulerBeat === 2) {
                           accentType = 'secondary';
                        }
                    }

                    playMetronomeClick(metronome.nextNoteTime, audioContext, metronome.gainNode, accentType);
                    
                    metronome.nextNoteTime += secondsPerClick;
                    metronome.currentSchedulerBeat = (metronome.currentSchedulerBeat + 1) % metronome.beatsPerBar;
                }
                if (metronome.isActive && isPlaying) { 
                    metronome.schedulerTimerId = setTimeout(metronomeScheduler, metronome.lookahead);
                } else {
                    stopMetronomePlayback();
                }
            }

            function playMetronomeClick(time, context, gain, accentType = 'normal') { 
                if (!gain || !context) return;
                const clickSoundParams = metronome.clickSounds[metronome.soundType];
                
                const osc = context.createOscillator();
                const clickGain = context.createGain(); 
                clickGain.connect(gain);
                osc.connect(clickGain);

                let frequency = clickSoundParams.freq2; 
                let gainValue = 1.0; 

                if (accentType === 'primary') {
                    frequency = clickSoundParams.freq1;
                    gainValue = 1.0;
                } else if (accentType === 'secondary' && clickSoundParams.freq3) {
                    frequency = clickSoundParams.freq3;
                    gainValue = 0.8; 
                } else {
                    gainValue = 0.7; 
                }

                osc.frequency.setValueAtTime(frequency, time);
                osc.type = clickSoundParams.type;

                clickGain.gain.setValueAtTime(gainValue, time);
                clickGain.gain.exponentialRampToValueAtTime(0.001, time + clickSoundParams.decay);

                osc.start(time);
                osc.stop(time + clickSoundParams.decay + 0.05); 

                if (metronome.soundType === 'madera_simulada' && clickSoundParams.noiseDuration) {
                    const noiseBuffer = context.createBuffer(1, Math.floor(context.sampleRate * clickSoundParams.noiseDuration), context.sampleRate);
                    const output = noiseBuffer.getChannelData(0);
                    let noiseGainMultiplier = 0.7; 
                    if (accentType === 'primary') noiseGainMultiplier = 1.0;
                    else if (accentType === 'secondary') noiseGainMultiplier = 0.85;

                    for (let i = 0; i < noiseBuffer.length; i++) {
                        output[i] = (Math.random() * 2 - 1) * noiseGainMultiplier;
                    }
                    const noiseSource = context.createBufferSource();
                    noiseSource.buffer = noiseBuffer;
                    
                    const noiseEnvelopeGain = context.createGain();
                    noiseEnvelopeGain.connect(gain);
                    noiseSource.connect(noiseEnvelopeGain);

                    noiseEnvelopeGain.gain.setValueAtTime(clickSoundParams.noiseGain * gainValue, time); 
                    noiseEnvelopeGain.gain.exponentialRampToValueAtTime(0.001, time + clickSoundParams.noiseDuration);
                    
                    noiseSource.start(time);
                    noiseSource.stop(time + clickSoundParams.noiseDuration + 0.05);
                }
            }
            
            function startMetronomePlayback(offlineCtx = null, offlineRenderDuration = 0) {
                const currentCtx = offlineCtx || audioContext;
                if (!metronome.isActive || !currentCtx) return;
            
                if (!offlineCtx) { 
                    if (metronome.isPlayingInternal) stopMetronomePlayback(); 
                    metronome.isPlayingInternal = true;
            
                    const secondsPerClick = getSecondsPerClick();
                    const elapsedTime = isPlaying ? (currentCtx.currentTime - globalStartTime) : globalPauseOffset;
                    const currentPlayheadTime = Math.max(0, elapsedTime);
                    
                    const clicksElapsed = currentPlayheadTime / secondsPerClick;
                    metronome.currentSchedulerBeat = Math.floor(clicksElapsed) % metronome.beatsPerBar;
                    
                    const nextClickIndex = Math.ceil(clicksElapsed - 0.0001); 
                    const baseTimeToCalcNextNote = isPlaying ? globalStartTime : currentCtx.currentTime - globalPauseOffset;
                    metronome.nextNoteTime = baseTimeToCalcNextNote + (nextClickIndex * secondsPerClick);
            
                    while (metronome.nextNoteTime < currentCtx.currentTime - 0.001) { 
                        metronome.nextNoteTime += secondsPerClick;
                        metronome.currentSchedulerBeat = (metronome.currentSchedulerBeat + 1) % metronome.beatsPerBar;
                    }
                    metronomeScheduler();
                } else { 
                    let scheduledTime = 0;
                    let currentBeatInBarOffline = 0; 
                    const secondsPerClickOffline = getSecondsPerClick(); 
                    const metronomeOfflineGain = offlineCtx.createGain();
                    metronomeOfflineGain.gain.value = metronome.volume;
                    metronomeOfflineGain.connect(offlineCtx.destination);
            
                    while (scheduledTime < offlineRenderDuration) {
                        let accentTypeOffline = 'normal';
                        if (currentBeatInBarOffline === 0) {
                            accentTypeOffline = 'primary';
                        } else if (metronome.beatValue === 8 && metronome.beatsPerBar % 3 === 0 && metronome.beatsPerBar > 3) {
                           if (metronome.beatsPerBar === 6 && currentBeatInBarOffline === 3) accentTypeOffline = 'secondary';
                           else if (metronome.beatsPerBar === 9 && (currentBeatInBarOffline === 3 || currentBeatInBarOffline === 6)) accentTypeOffline = 'secondary';
                           else if (metronome.beatsPerBar === 12 && (currentBeatInBarOffline === 3 || currentBeatInBarOffline === 6 || currentBeatInBarOffline === 9)) accentTypeOffline = 'secondary';
                        } else if (metronome.beatsPerBar === 4 && metronome.beatValue === 4 && currentBeatInBarOffline === 2) {
                           accentTypeOffline = 'secondary';
                        }
                        playMetronomeClick(scheduledTime, offlineCtx, metronomeOfflineGain, accentTypeOffline);
                        scheduledTime += secondsPerClickOffline;
                        currentBeatInBarOffline = (currentBeatInBarOffline + 1) % metronome.beatsPerBar;
                    }
                }
            }


            function stopMetronomePlayback() {
                clearTimeout(metronome.schedulerTimerId);
                metronome.schedulerTimerId = null;
                metronome.isPlayingInternal = false;
            }

            // --- FUNCIONES DE FORMA DE ONDA ---
            async function generateMixedAudioBuffer() {
                if (!tracks.length || maxDuration === 0) {
                    mixedAudioBuffer = null;
                    return;
                }
                if (!audioContext) initAudioContext();

                const targetSampleRate = audioContext.sampleRate;
                const numberOfChannels = audioContext.destination.channelCount > 0 ? audioContext.destination.channelCount : 2;
                const offlineCtx = new OfflineAudioContext(numberOfChannels, Math.ceil(targetSampleRate * maxDuration), targetSampleRate);
                const offlineMasterGain = offlineCtx.createGain();
                offlineMasterGain.gain.value = 1.0; 
                offlineMasterGain.connect(offlineCtx.destination);

                for (const track of tracks) {
                    if (track.audioBuffer) {
                        const source = offlineCtx.createBufferSource();
                        source.buffer = track.audioBuffer;
                        const trackGain = offlineCtx.createGain();
                        trackGain.gain.value = track.volume; // Mezcla para forma de onda usa solo volumen de pista
                        source.connect(trackGain);
                        trackGain.connect(offlineMasterGain);
                        source.start(0);
                    }
                }
                try {
                    mixedAudioBuffer = await offlineCtx.startRendering();
                } catch (err) {
                    console.error("Error generando buffer de mezcla para forma de onda:", err);
                    mixedAudioBuffer = null;
                }
            }

            function drawWaveform() {
                if (!waveformCtx) return; // Asegurar que el contexto del canvas existe
                
                const width = waveformCanvas.width;
                const height = waveformCanvas.height;
                waveformCtx.clearRect(0, 0, width, height);

                // Obtener colores de las variables CSS
                const waveColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim();
                const bgColor = getComputedStyle(document.documentElement).getPropertyValue('--surface-color').trim(); // Fondo del canvas
                // const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim(); // Borde del canvas

                // Dibujar fondo (opcional, si el canvas CSS no lo cubre)
                // waveformCtx.fillStyle = bgColor;
                // waveformCtx.fillRect(0, 0, width, height);

                if (!mixedAudioBuffer) {
                    // Podrías dibujar una línea central o nada si no hay buffer
                    waveformCtx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--secondary-color').trim();
                    waveformCtx.beginPath();
                    waveformCtx.moveTo(0, height / 2);
                    waveformCtx.lineTo(width, height / 2);
                    waveformCtx.stroke();
                    return;
                }
                
                waveformCtx.lineWidth = 1.5; 
                waveformCtx.strokeStyle = waveColor;
                waveformCtx.beginPath();

                const data = mixedAudioBuffer.getChannelData(0); 
                const step = Math.ceil(data.length / width);
                const amp = height / 2;

                for (let i = 0; i < width; i++) {
                    let min = 1.0;
                    let max = -1.0;
                    for (let j = 0; j < step; j++) {
                        const datum = data[(i * step) + j];
                        if (datum === undefined) continue; // Evitar errores si data.length no es múltiplo perfecto
                        if (datum < min) min = datum;
                        if (datum > max) max = datum;
                    }
                    waveformCtx.moveTo(i + 0.5, (1 + min) * amp); // +0.5 para líneas más nítidas
                    waveformCtx.lineTo(i + 0.5, (1 + max) * amp);
                }
                waveformCtx.stroke();
            }

            async function regenerateAndDrawWaveform() {
                if (tracks.length > 0 && maxDuration > 0) {
                    const كان_يصدر = exportMixButton.disabled; // Guardar estado
                    exportMixButton.disabled = true; 
                    await generateMixedAudioBuffer();
                    drawWaveform();
                    exportMixButton.disabled = كان_يصدر; // Restaurar estado
                } else {
                    mixedAudioBuffer = null; 
                    drawWaveform(); 
                }
            }

            waveformCanvas.addEventListener('mousedown', (event) => {
                if (maxDuration === 0 || !mixedAudioBuffer) return;
                isScrubbingWaveform = true;
                handleWaveformScrub(event);
            });
            document.addEventListener('mousemove', (event) => {
                if (!isScrubbingWaveform || maxDuration === 0 || !mixedAudioBuffer) return;
                handleWaveformScrub(event);
            });
            document.addEventListener('mouseup', () => {
                if (isScrubbingWaveform) {
                    isScrubbingWaveform = false;
                    saveSession(); 
                }
            });
            waveformCanvas.addEventListener('touchstart', (event) => {
                if (maxDuration === 0 || !mixedAudioBuffer) return;
                isScrubbingWaveform = true;
                handleWaveformScrub(event.touches[0]);
            }, { passive: false }); // passive: false para permitir preventDefault
            document.addEventListener('touchmove', (event) => {
                 if (!isScrubbingWaveform || maxDuration === 0 || !mixedAudioBuffer) return;
                 event.preventDefault(); 
                 handleWaveformScrub(event.touches[0]);
            }, { passive: false });
            document.addEventListener('touchend', () => {
                if (isScrubbingWaveform) {
                    isScrubbingWaveform = false;
                    saveSession();
                }
            });

            function handleWaveformScrub(event) {
                if (!audioContext || maxDuration === 0) return;
                const rect = waveformCanvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const progressRatio = Math.max(0, Math.min(1, x / rect.width));
                const seekTime = progressRatio * maxDuration;

                const wasPlaying = isPlaying;
                if (wasPlaying) {
                    pauseAll();
                }
                
                globalPauseOffset = seekTime;
                if (!wasPlaying) {
                     globalStartTime = audioContext.currentTime - globalPauseOffset;
                }
                
                updateUI(); 

                if (wasPlaying) {
                    playAll();
                } else if (metronome.isActive) {
                    stopMetronomePlayback();
                }
            }
            // --- FIN FUNCIONES DE FORMA DE ONDA ---


            exportMixButton.addEventListener('click', async () => {
                if (!tracks.length || maxDuration === 0) {
                    exportMessage.textContent = "No hay audio para exportar.";
                    return;
                }
                if (!audioContext) initAudioContext();

                const format = exportFormatSelect.value;
                exportMessage.textContent = `Exportando como ${format.toUpperCase()}...`;
                exportMixButton.disabled = true;
                exportProgressContainer.style.display = 'block';
                exportProgressBar.style.width = '0%';

                try {
                    const sampleRate = audioContext.sampleRate;
                    const numberOfChannels = audioContext.destination.channelCount > 0 ? audioContext.destination.channelCount : 2;
                    const offlineCtx = new OfflineAudioContext(numberOfChannels, Math.ceil(sampleRate * maxDuration), sampleRate);


                    const offlineMasterGain = offlineCtx.createGain();
                    offlineMasterGain.gain.value = parseFloat(masterVolumeSlider.value);
                    offlineMasterGain.connect(offlineCtx.destination);

                    const anySoloActive = tracks.some(t => t.isSoloed);

                    await new Promise(resolve => setTimeout(resolve, 50));
                    exportProgressBar.style.width = '10%';

                    for (let i = 0; i < tracks.length; i++) {
                        const track = tracks[i];
                        if (track.audioBuffer) {
                            const source = offlineCtx.createBufferSource();
                            source.buffer = track.audioBuffer;
                            const trackGain = offlineCtx.createGain();
                            applyEffectiveVolume(track.id, anySoloActive, trackGain);
                            source.connect(trackGain);
                            trackGain.connect(offlineMasterGain);
                            source.start(0);
                        }
                        exportProgressBar.style.width = `${10 + Math.floor((i / tracks.length) * 60)}%`;
                    }

                    if (metronome.isActive) {
                        startMetronomePlayback(offlineCtx, maxDuration);
                    }
                    exportProgressBar.style.width = '70%';

                    const renderedBuffer = await offlineCtx.startRendering();
                    exportProgressBar.style.width = '90%';

                    if (format === 'wav') {
                        const wavBlob = audioBufferToWav(renderedBuffer);
                        downloadBlob(wavBlob, `TZU-Worship-Mezcla_${Date.now()}.wav`);
                        exportMessage.textContent = "Exportación WAV completada.";
                    } else if (format === 'mp3') {
                        exportMessage.textContent = "Formato MP3 no implementado aún.";
                    }
                    exportProgressBar.style.width = '100%';

                } catch (err) {
                    console.error("Error durante la exportación:", err);
                    exportMessage.textContent = "Error en la exportación.";
                    exportProgressBar.style.width = '0%';
                } finally {
                    exportMixButton.disabled = false;
                    setTimeout(() => {
                         exportProgressContainer.style.display = 'none';
                         exportProgressBar.style.width = '0%';
                         exportMessage.textContent = "";
                    }, 4000);
                }
            });

            function audioBufferToWav(buffer) {
                let numOfChan = buffer.numberOfChannels,
                    dataLength = buffer.length * numOfChan * 2,
                    btwLength = dataLength + 44,
                    btwArrBuff = new ArrayBuffer(btwLength),
                    btwView = new DataView(btwArrBuff),
                    btwChnls = [],
                    btwIndex,
                    btwSample,
                    btwOffset = 0,
                    headerPos = 0;

                setUint32(0x46464952); 
                setUint32(btwLength - 8); 
                setUint32(0x45564157); 
                setUint32(0x20746d66); 
                setUint32(16); 
                setUint16(1); 
                setUint16(numOfChan);
                setUint32(buffer.sampleRate);
                setUint32(buffer.sampleRate * numOfChan * 2); 
                setUint16(numOfChan * 2); 
                setUint16(16); 
                setUint32(0x61746164); 
                setUint32(dataLength); 

                for (btwIndex = 0; btwIndex < buffer.numberOfChannels; btwIndex++)
                    btwChnls.push(buffer.getChannelData(btwIndex));

                let dataPos = 44; 
                for (btwOffset = 0; btwOffset < buffer.length; btwOffset++) {
                    for (btwIndex = 0; btwIndex < numOfChan; btwIndex++) {
                        btwSample = Math.max(-1, Math.min(1, btwChnls[btwIndex][btwOffset]));
                        btwSample = (0.5 + btwSample < 0 ? btwSample * 32768 : btwSample * 32767) | 0;
                        btwView.setInt16(dataPos, btwSample, true);
                        dataPos += 2;
                    }
                }
                return new Blob([btwView], { type: "audio/wav" });

                function setUint16(data) {
                    btwView.setUint16(headerPos, data, true);
                    headerPos += 2;
                }
                function setUint32(data) {
                    btwView.setUint32(headerPos, data, true);
                    headerPos += 4;
                }
            }

            function downloadBlob(blob, filename) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                document.body.appendChild(a);
                a.style = "display: none";
                a.href = url;
                a.download = filename;
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
            }
            
            function getSessionDataForSave() {
                 return {
                    version: "1.3.14-waveform-scrubber", 
                    tracks: tracks.map(t => ({ 
                        volume: t.volume, isMuted: t.isMuted, isSoloed: t.isSoloed,
                        loadedFileName: t.loadedFileName, 
                        fileUrl: t.fileUrl, 
                        sourceType: t.sourceType 
                    })),
                    metronome: { 
                        bpm: metronome.bpm, 
                        timeSignature: timeSignatureInput.value,
                        isActive: metronome.isActive, 
                        soundType: metronome.soundType, 
                        volume: metronome.volume 
                    },
                    masterVolume: parseFloat(masterVolumeSlider.value),
                    globalScrubberValue: parseFloat(globalPauseOffset) || 0 // Guardar globalPauseOffset
                };
            }

            function resetGlobalToggleButtonsToDefaults() {
                isSoloButtonInRestoreMode = false;
                toggleGlobalSoloButton.textContent = SOLO_BUTTON_TEXT.CLEAR;
                toggleGlobalSoloButton.classList.add('secondary');
                toggleGlobalSoloButton.classList.remove('toggled');
                previousSoloedTrackIds = [];

                isMuteButtonInRestoreMode = false;
                toggleGlobalMuteButton.textContent = MUTE_BUTTON_TEXT.CLEAR;
                toggleGlobalMuteButton.classList.add('secondary');
                toggleGlobalMuteButton.classList.remove('toggled');
                previousMutedTrackIds = [];
            }
            
            const LS_KEY = 'multipistaAdvancedSession_v1.3.14'; 
            function saveSession() {
                if (typeof localStorage === 'undefined') return; const sessionData = getSessionDataForSave();
                try { localStorage.setItem(LS_KEY, JSON.stringify(sessionData)); }
                catch (e) { console.warn("No se pudo guardar la sesión en LS:", e); }
            }
            
            async function loadSession() { 
                if (typeof localStorage === 'undefined') return;
                try {
                    const savedSession = localStorage.getItem(LS_KEY);
                    if (savedSession) {
                        const data = JSON.parse(savedSession);
                        await applyLoadedData(data); 
                        resetGlobalToggleButtonsToDefaults();
                        console.log("Sesión anterior cargada desde LocalStorage.");
                        loadingMessage.textContent = "Sesión anterior cargada."; 
                         setTimeout(() => loadingMessage.textContent = "", 6000);
                    } else {
                        console.log("No hay sesión guardada para cargar.");
                        const initialTimeSig = timeSignatureInput.value.trim().split('/');
                        if(initialTimeSig.length === 2){
                            metronome.timeSignature = [parseInt(initialTimeSig[0]), parseInt(initialTimeSig[1])];
                            metronome.beatsPerBar = metronome.timeSignature[0];
                            metronome.beatValue = metronome.timeSignature[1];
                        }
                        tempoInput.value = metronome.bpm;
                        clickSoundSelect.value = metronome.soundType;
                        metronomeVolumeSlider.value = metronome.volume;
                        // Dibujar forma de onda vacía si no hay sesión
                        await regenerateAndDrawWaveform(); 
                    }
                } catch (e) { 
                    console.warn("No se pudo cargar la sesión desde LS:", e); 
                    localStorage.removeItem(LS_KEY); 
                    const initialTimeSig = timeSignatureInput.value.trim().split('/');
                     if(initialTimeSig.length === 2){
                        metronome.timeSignature = [parseInt(initialTimeSig[0]), parseInt(initialTimeSig[1])];
                        metronome.beatsPerBar = metronome.timeSignature[0];
                        metronome.beatValue = metronome.timeSignature[1];
                    }
                    tempoInput.value = metronome.bpm;
                    clickSoundSelect.value = metronome.soundType;
                    metronomeVolumeSlider.value = metronome.volume;
                    await regenerateAndDrawWaveform(); // Dibujar forma de onda vacía en error
                }
            }


            async function applyLoadedData(data) { 
                initAudioContext();
                tracksContainer.innerHTML = ''; tracks = []; nextTrackId = 0; maxDuration = 0;
                tracksContainerPlaceholder.style.display = 'block';
                exportMixButton.disabled = true;

                if (data.tracks && Array.isArray(data.tracks) && data.tracks.length > 0) {
                    for (const trackData of data.tracks) {
                        let trackFileName = trackData.loadedFileName || trackData.fileUrl?.substring(trackData.fileUrl.lastIndexOf('/') + 1).split('?')[0] || "Pista Desconocida";
                        if (trackFileName.length > 50) trackFileName = trackFileName.substring(0,47) + "...";

                        let newTrackArgs = {
                            fileName: trackFileName, audioBuffer: null,
                            fileUrl: trackData.fileUrl,
                            sourceType: trackData.sourceType || (trackData.fileUrl ? 'url' : 'project-placeholder'),
                            existingTrackData: trackData
                        };

                        const trackObject = createAndAddTrackElement(newTrackArgs);

                        if (trackData.fileUrl && trackObject.sourceType === 'url') {
                            updateTrackStatusIndicator(trackObject.id, "Cargando URL...");
                            try {
                                const response = await fetch(trackData.fileUrl);
                                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                                const arrayBuffer = await response.arrayBuffer();
                                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                                trackObject.audioBuffer = audioBuffer;
                                trackObject.duration = audioBuffer.duration;
                                updateTrackStatusIndicator(trackObject.id, "URL Cargada OK");
                            } catch (err) {
                                console.error(`Error cargando desde URL ${trackData.fileUrl}:`, err);
                                updateTrackStatusIndicator(trackObject.id, `Error URL`, true);
                            }
                        } else if (trackObject.sourceType === 'project-placeholder' && trackData.loadedFileName) {
                           updateTrackStatusIndicator(trackObject.id, "Recargar localmente");
                        } else if (trackObject.sourceType === 'local' && trackData.loadedFileName){
                            updateTrackStatusIndicator(trackObject.id, "Recargar localmente");
                        }
                    }
                     exportMixButton.disabled = false;
                } else {
                    tracksContainerPlaceholder.style.display = 'block';
                    exportMixButton.disabled = true;
                }

                if (data.metronome) {
                    tempoInput.value = data.metronome.bpm || 120; 
                    metronome.bpm = parseInt(tempoInput.value);

                    timeSignatureInput.value = data.metronome.timeSignature || "4/4";
                    const parts = timeSignatureInput.value.trim().split('/');
                    if (parts.length === 2) {
                        const num = parseInt(parts[0]);
                        const den = parseInt(parts[1]);
                        if (!isNaN(num) && !isNaN(den) && num > 0 && num <=16 && den > 0 && [2,4,8,16].includes(den)) {
                            metronome.timeSignature = [num, den];
                            metronome.beatsPerBar = num;
                            metronome.beatValue = den;
                        } else {
                            metronome.timeSignature = [4,4]; 
                            metronome.beatsPerBar = 4;
                            metronome.beatValue = 4;
                            timeSignatureInput.value = "4/4";
                        }
                    } else {
                        metronome.timeSignature = [4,4];
                        metronome.beatsPerBar = 4;
                        metronome.beatValue = 4;
                        timeSignatureInput.value = "4/4";
                    }


                    clickSoundSelect.value = data.metronome.soundType || "madera_simulada"; 
                    metronome.soundType = clickSoundSelect.value;
                    metronomeVolumeSlider.value = data.metronome.volume !== undefined ? data.metronome.volume : 0.7; 
                    metronome.volume = parseFloat(metronomeVolumeSlider.value);
                    if(metronome.gainNode && audioContext) metronome.gainNode.gain.setValueAtTime(metronome.volume, audioContext.currentTime);
                    
                    const currentMetronomeActiveState = metronome.isActive;
                    if (data.metronome.isActive && !currentMetronomeActiveState) {
                        metronomeToggleButton.click(); 
                    } else if (!data.metronome.isActive && currentMetronomeActiveState) {
                        metronomeToggleButton.click(); 
                    } else { 
                         if (metronome.isActive) {
                            metronomeToggleButton.textContent = '🔊 Click ON'; 
                            metronomeToggleButton.classList.add('active'); 
                            metronomeToggleButton.classList.remove('inactive');
                         } else {
                            metronomeToggleButton.textContent = '🔇 Click OFF'; 
                            metronomeToggleButton.classList.remove('active'); 
                            metronomeToggleButton.classList.add('inactive');
                         }
                    }
                }


                masterVolumeSlider.value = data.masterVolume || 0.8;
                if (masterGainNode && audioContext) masterGainNode.gain.setValueAtTime(parseFloat(masterVolumeSlider.value), audioContext.currentTime);
                
                // Restaurar globalPauseOffset ANTES de llamar a updateMaxDurationAndScrubber
                globalPauseOffset = data.globalScrubberValue || 0;

                updateAllTrackVisualsAndVolumes();
                await updateMaxDurationAndScrubber(); // Hacerlo async y esperar
                updateUI(); // Asegurar que la UI (incluido el cursor) se actualice después de todo
            }

            (async () => {
                // Comentado para que no cargue sesión al inicio por defecto
                // await loadSession(); 

                if (tracks.length === 0) {
                    tracksContainerPlaceholder.style.display = 'block';
                    exportMixButton.disabled = true;
                    progressCursor.style.left = '0%';
                }
                
                const initialTimeSigParts = timeSignatureInput.value.trim().split('/');
                if (initialTimeSigParts.length === 2) {
                    const num = parseInt(initialTimeSigParts[0]);
                    const den = parseInt(initialTimeSigParts[1]);
                    if (!isNaN(num) && !isNaN(den) && num > 0 && den > 0) {
                        metronome.timeSignature = [num, den];
                        metronome.beatsPerBar = num;
                        metronome.beatValue = den;
                    }
                } 
                metronome.bpm = parseInt(tempoInput.value);
                metronome.soundType = clickSoundSelect.value; 
                metronome.volume = parseFloat(metronomeVolumeSlider.value);

                waveformCanvas.width = waveformCanvas.offsetWidth || 600; // Fallback si offsetWidth es 0
                waveformCanvas.height = 80; 
                waveformCanvas.style.height = '80px'; 
                progressCursor.style.height = `${waveformCanvas.height}px`;

                window.addEventListener('resize', () => { 
                    if (waveformCanvas.offsetWidth > 0) { // Solo redimensionar si es visible
                        waveformCanvas.width = waveformCanvas.offsetWidth;
                    }
                    // waveformCanvas.height = 80; // Mantener altura fija
                    drawWaveform();
                    updateUI(); 
                });

                if (maxDuration > 0) {
                    await regenerateAndDrawWaveform();
                } else {
                    drawWaveform(); 
                }

                resetGlobalToggleButtonsToDefaults();
                updateUI();
            })();

        });
    </script>
</body>
</html>
